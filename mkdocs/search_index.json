{
    "docs": [
        {
            "location": "/", 
            "text": "Node Editor Framework\n\n\n\n\nA free and versatile Node Editor Framework for Unity 3D\n\n\n\n\n\n\nThe Texture Composer example, available on the Repo\n\n\n\n\nLinks:\n\n\nGithub Repository\n\n\n\n\nUnity Forum Thread\n\n\n\n\nThis documentation was originally created by \nSeneral\n. It is still a WIP.\n\n\n\nLast update: (21.08.16)\n\n\n\n\n \n \n \n\n\nPreface\n\n\nThis Documentation intends to give you an overview of the Node Editor. It was initially posted by me, \nSeneral\n, \nback in May 2015 as a personal project on the \nUnity Forums\n.\nAfter receiving a great amount of positive feedback I continued improving and supporting it, now, with the help of the community, featuring a lot of major features you'd expect from a great Node Editor!\n\n\nThe \nGithub Repository\n was set up by \nBaste\n \nduring the early development, and now it's the main platform to share and contribute to Node Editor.\n\n\n \n\n\nFeatures\n\n\nThe Node Editor has some unique features despite being Open-Source, which we're proud of featuring:\n\n\n\n\nFull interface with all expected controls like zooming/panning\n\n\nFlexible and interchangeable GUI\n\n\nCanvas and Editor State system featuring alot of advanced controls\n\n\nSuper easy to extend with custom nodes, types and even controls without modifying the provided code\n\n\nPowerful calculation system, soon revamped for complete flexibility\n\n\nExtreme Node customization to create totally unique node appearances achieved by a custom windowing system\n\n\nGrowing Runtime support, including every bit from the EditorWindow\n\n\n\n\nThe framework also shines with clean and easy to modify code. It's clearly separated in multiple parts, \nsome of which can even be taken and used somewhere else, such as the unique, generic scaling approach!\n\n\n \n\n\nContributing\n\n\nSince the initial start quite a few people took the time and motivation to contribute to the project which we all appreciate very much! \nYou can check all contributions out on the contributions page. But also those who use, test and report bugs are very important for this project.\n\n\nIf you wish to contribute, you may take a look at the \nIssues page of Github\n as a rough guideline what is planned and how you can help. \nOf course, own ideas are just as fine. Make sure to let us know if you are making an extension using Node Editor, may it be big or small, and notify me about any problems you may encounter:)\nThis is vital to the project!\n\n\nAlso, you can always contact Seneral with a PM on the Forums for questions on the framework:)\n\n\n \n\n\nLicense\n\n\nThis software is distributed under the \nMIT License", 
            "title": "Home"
        }, 
        {
            "location": "/#node-editor-framework", 
            "text": "A free and versatile Node Editor Framework for Unity 3D    The Texture Composer example, available on the Repo   Links:  Github Repository   Unity Forum Thread   This documentation was originally created by  Seneral . It is still a WIP.  Last update: (21.08.16)", 
            "title": "Node Editor Framework"
        }, 
        {
            "location": "/#preface", 
            "text": "This Documentation intends to give you an overview of the Node Editor. It was initially posted by me,  Seneral , \nback in May 2015 as a personal project on the  Unity Forums .\nAfter receiving a great amount of positive feedback I continued improving and supporting it, now, with the help of the community, featuring a lot of major features you'd expect from a great Node Editor!  The  Github Repository  was set up by  Baste  \nduring the early development, and now it's the main platform to share and contribute to Node Editor.", 
            "title": "Preface"
        }, 
        {
            "location": "/#features", 
            "text": "The Node Editor has some unique features despite being Open-Source, which we're proud of featuring:   Full interface with all expected controls like zooming/panning  Flexible and interchangeable GUI  Canvas and Editor State system featuring alot of advanced controls  Super easy to extend with custom nodes, types and even controls without modifying the provided code  Powerful calculation system, soon revamped for complete flexibility  Extreme Node customization to create totally unique node appearances achieved by a custom windowing system  Growing Runtime support, including every bit from the EditorWindow   The framework also shines with clean and easy to modify code. It's clearly separated in multiple parts, \nsome of which can even be taken and used somewhere else, such as the unique, generic scaling approach!", 
            "title": "Features"
        }, 
        {
            "location": "/#contributing", 
            "text": "Since the initial start quite a few people took the time and motivation to contribute to the project which we all appreciate very much! \nYou can check all contributions out on the contributions page. But also those who use, test and report bugs are very important for this project.  If you wish to contribute, you may take a look at the  Issues page of Github  as a rough guideline what is planned and how you can help. \nOf course, own ideas are just as fine. Make sure to let us know if you are making an extension using Node Editor, may it be big or small, and notify me about any problems you may encounter:)\nThis is vital to the project!  Also, you can always contact Seneral with a PM on the Forums for questions on the framework:)", 
            "title": "Contributing"
        }, 
        {
            "location": "/#license", 
            "text": "This software is distributed under the  MIT License", 
            "title": "License"
        }, 
        {
            "location": "/GettingStarted/", 
            "text": "Getting Started\n\n\n\n\nInstallation\n\n\nInstalling is as simple as dragging and dropping the \nEditor\n and \nNode_Editor\n folders into your project at \nAssets/Plugins\n. It will work anywhere but would require a change in source for long term usage.\nYou are then able to open the window at '\nWindow/Node Editor\n' when there are no errors in the project.\n\n\n\n\nExamples\n\n\nEditor \n Canvas\n\n\nYou can start off by opening the Editor Window at '\nWindow/Node Editor\n' and loading an example canvas, such as the \nCalculationCanvas\n. \nUse either the button at the top right or locate it in the project folder and double-click it.\n\n\nUsing context-clicks you can manipulate the canvas, using drag'n'drop you can drag around and connect node outputs and inputs with each other. \n\nControl\n will snap nodes to the grid and \nN\n will help you navigate back to the origin or the selected node!\n\n\nExample Extensions\n\n\nFor examples on simple extensions, check out all '\nExamples/\n'-Subbranches on the repository! \n\nOne of the currently available examples is the \nTexture Composer\n, \nan example of adding Nodes and ConnectionTypes to extend the framework to simple texture manipulation capabilities. \n\nAnother is the \nDialogue System\n, \nwhich demonstrates the actual usage of a canvas at runtime to drive a simple dialogue.\n\n\nExample Runtime Usage\n\n\nFor more general ideas on how to use the canvas at runtime, you can check out \nRTCanvasCalculator\n, which is a component that can \ncalculate and debug the canvas at runtime and also implements some basic but useful helper functions to traverse the canvas at runtime. \n\nIt is also possible to show the actual GUI at runtime, as \nRuntimeNodeEditor\n demonstrates. It works and looks very similar to the editor window \nwith some limitations due to inaccessibility to the UnityEditor namespace. But aslong as the Nodes use \nRTEditorGUI\n for available UI controls \nand encapsulate all editor-only GUI parts into a preprocessor checks, it is totally possible to give your player access to a Node Editor:)", 
            "title": "Getting Started"
        }, 
        {
            "location": "/GettingStarted/#getting-started", 
            "text": "", 
            "title": "Getting Started"
        }, 
        {
            "location": "/GettingStarted/#installation", 
            "text": "Installing is as simple as dragging and dropping the  Editor  and  Node_Editor  folders into your project at  Assets/Plugins . It will work anywhere but would require a change in source for long term usage.\nYou are then able to open the window at ' Window/Node Editor ' when there are no errors in the project.", 
            "title": "Installation"
        }, 
        {
            "location": "/GettingStarted/#examples", 
            "text": "", 
            "title": "Examples"
        }, 
        {
            "location": "/GettingStarted/#editor-canvas", 
            "text": "You can start off by opening the Editor Window at ' Window/Node Editor ' and loading an example canvas, such as the  CalculationCanvas . \nUse either the button at the top right or locate it in the project folder and double-click it.  Using context-clicks you can manipulate the canvas, using drag'n'drop you can drag around and connect node outputs and inputs with each other.  Control  will snap nodes to the grid and  N  will help you navigate back to the origin or the selected node!", 
            "title": "Editor &amp; Canvas"
        }, 
        {
            "location": "/GettingStarted/#example-extensions", 
            "text": "For examples on simple extensions, check out all ' Examples/ '-Subbranches on the repository!  \nOne of the currently available examples is the  Texture Composer , \nan example of adding Nodes and ConnectionTypes to extend the framework to simple texture manipulation capabilities.  \nAnother is the  Dialogue System , \nwhich demonstrates the actual usage of a canvas at runtime to drive a simple dialogue.", 
            "title": "Example Extensions"
        }, 
        {
            "location": "/GettingStarted/#example-runtime-usage", 
            "text": "For more general ideas on how to use the canvas at runtime, you can check out  RTCanvasCalculator , which is a component that can \ncalculate and debug the canvas at runtime and also implements some basic but useful helper functions to traverse the canvas at runtime.  \nIt is also possible to show the actual GUI at runtime, as  RuntimeNodeEditor  demonstrates. It works and looks very similar to the editor window \nwith some limitations due to inaccessibility to the UnityEditor namespace. But aslong as the Nodes use  RTEditorGUI  for available UI controls \nand encapsulate all editor-only GUI parts into a preprocessor checks, it is totally possible to give your player access to a Node Editor:)", 
            "title": "Example Runtime Usage"
        }, 
        {
            "location": "/BuildingExtensions/", 
            "text": "Building Extensions - Overview\n\n\nThese pages will guide you to create your own extension without touching the framework code.\nThis is possible by dynamically fetching extending content from all assemblies and even enables user extensions.\n\n\nIf you want/need to create modify the framework for your extension, you can refer to the \nFramework Overview\n to get a glimpse on how each framework part works.\n\n\n\n\nCovered Topics\n\n\n\n\n\n- \n \nCustom Nodes\n - Implementation of custom Nodes\n\n\n- \n \nCustom ConnectionTypes\n - Defining custom ConnectinTypes in order to pass custom types with customized visualization\n\n\n- \n \nAdding NodeCanvas Types\n - Implementation of custom NodeCanvas Types for customized situations\n\n\n- \n \nAdding Input Controls\n - Addition of Input Controls to the dynamic Input System with Attribbutes\n\n\n- \n \nBuilding an Editor\n - Building of a custom Editor Window or other user of the Node Editor Framework\n\n\n- \n \nEvent \n Callbacks\n - Making use of the framework events and callbacks", 
            "title": "Overview"
        }, 
        {
            "location": "/BuildingExtensions/#building-extensions-overview", 
            "text": "These pages will guide you to create your own extension without touching the framework code.\nThis is possible by dynamically fetching extending content from all assemblies and even enables user extensions. \nIf you want/need to create modify the framework for your extension, you can refer to the  Framework Overview  to get a glimpse on how each framework part works.", 
            "title": "Building Extensions - Overview"
        }, 
        {
            "location": "/BuildingExtensions/#covered-topics", 
            "text": "-    Custom Nodes  - Implementation of custom Nodes \n-    Custom ConnectionTypes  - Defining custom ConnectinTypes in order to pass custom types with customized visualization \n-    Adding NodeCanvas Types  - Implementation of custom NodeCanvas Types for customized situations \n-    Adding Input Controls  - Addition of Input Controls to the dynamic Input System with Attribbutes \n-    Building an Editor  - Building of a custom Editor Window or other user of the Node Editor Framework \n-    Event   Callbacks  - Making use of the framework events and callbacks", 
            "title": "Covered Topics"
        }, 
        {
            "location": "/BuildingExtensions/CustomNodes/", 
            "text": "Custom Nodes\n\n\nThe implementation of additional, custom nodes is fairly easy. You have to create a script anywhere in the project extending the \nNodeEditorFramework.Node\n class.\nIt will provide the Framework all needed information about the node itself, the optional \nNode\n attribute contains information about the presentation in the editor.\nThe Framework will search all script assemblies for additional nodes, so extra setup is not required. If you do need a custom assembly to be included, you can add it manually in \nNodeTypes.cs\n.\n\n\nThe following outlines the necessary Node members. You can take reference from the ExampleNode found in '\nPlugins/Node_Editor/Nodes/Example\n'.\nFirst to mention is that even though the Framework is programmed in C#, you can add nodes in UnityScript with the limitation that they have to be compiled in phase 2,3 or 4, \nas described \nhere\n. Therefore the following members are described language independently.\n\n\n\n\nimport/use \nNodeEditorFramework\n\n\nClass extending \nNode\n\n\nOptional\n: Attribute \nNode\n \n[params: [Bool] hide; [String] contextPath; optional [Type] canvasType]\n\n\nUnique Node ID; declare: \nID\n \n[constant string]\n; expose: property \nGetID\n[Override]\n\n\nOptional\n: Behaviour Options\n\n\nAllowRecursion\n \n[override, default: false]\n\n\nContinueCalculation\n \n[override, default: true]\n\n\nAcceptsTransitions\n \n[override, default: false]\n\n\n\n\n\n\nMethod \nCreate\n \n[override; Params: [Vector2] position; Returns : [Node] created node]\n\n\nCreate a new Node of your type using \nCreateInstance\n and assign it's property \nrect\n using the position parameter\n\n\nAdd connections using \nCreateInput\n/\nCreateOutput\n or \nNodeInput.Create\n/\nNodeOuput.Create\n \n[Params: name; type ID; side; position]\n\n\nPerform any other additional setup steps and return your created node\n\n\n\n\n\n\nMethod \nNodeGUI\n \n[protected (internal) override]\n\n\nDraw your Node's GUI; you may use GUILayout functions\n\n\nAccess the Inputs/Outputs using the respective arrays in the order of creation. \n  Use their methods \nDisplayLayout\n or \nSetPosition\n to position (and draw) them.\n\n\n\n\n\n\nMethod \nCalculate\n \n[override]\n\n\nThe methods \nallInputsReady\n, \nhasUnassignedInputs\n and \ndescendantsCalculated\n \n  may help to check if the node is ready, based on the needs and purposes of it.\n\n\nGet the input values by calling \nGetValue\n on the NodeInputs and set the output values with \nSetValue\n the same way.\n\n\nReturn \ntrue\n when you're done calculating and \nfalse\n when you are not ready yet and need another attempt. \n  But be aware, you cannot yield calculation that way, after a maximum of a \nthousand\n repeated tries the calculation will be aborted!", 
            "title": "Custom Nodes"
        }, 
        {
            "location": "/BuildingExtensions/CustomNodes/#custom-nodes", 
            "text": "The implementation of additional, custom nodes is fairly easy. You have to create a script anywhere in the project extending the  NodeEditorFramework.Node  class.\nIt will provide the Framework all needed information about the node itself, the optional  Node  attribute contains information about the presentation in the editor.\nThe Framework will search all script assemblies for additional nodes, so extra setup is not required. If you do need a custom assembly to be included, you can add it manually in  NodeTypes.cs .  The following outlines the necessary Node members. You can take reference from the ExampleNode found in ' Plugins/Node_Editor/Nodes/Example '.\nFirst to mention is that even though the Framework is programmed in C#, you can add nodes in UnityScript with the limitation that they have to be compiled in phase 2,3 or 4, \nas described  here . Therefore the following members are described language independently.   import/use  NodeEditorFramework  Class extending  Node  Optional : Attribute  Node   [params: [Bool] hide; [String] contextPath; optional [Type] canvasType]  Unique Node ID; declare:  ID   [constant string] ; expose: property  GetID [Override]  Optional : Behaviour Options  AllowRecursion   [override, default: false]  ContinueCalculation   [override, default: true]  AcceptsTransitions   [override, default: false]    Method  Create   [override; Params: [Vector2] position; Returns : [Node] created node]  Create a new Node of your type using  CreateInstance  and assign it's property  rect  using the position parameter  Add connections using  CreateInput / CreateOutput  or  NodeInput.Create / NodeOuput.Create   [Params: name; type ID; side; position]  Perform any other additional setup steps and return your created node    Method  NodeGUI   [protected (internal) override]  Draw your Node's GUI; you may use GUILayout functions  Access the Inputs/Outputs using the respective arrays in the order of creation. \n  Use their methods  DisplayLayout  or  SetPosition  to position (and draw) them.    Method  Calculate   [override]  The methods  allInputsReady ,  hasUnassignedInputs  and  descendantsCalculated  \n  may help to check if the node is ready, based on the needs and purposes of it.  Get the input values by calling  GetValue  on the NodeInputs and set the output values with  SetValue  the same way.  Return  true  when you're done calculating and  false  when you are not ready yet and need another attempt. \n  But be aware, you cannot yield calculation that way, after a maximum of a  thousand  repeated tries the calculation will be aborted!", 
            "title": "Custom Nodes"
        }, 
        {
            "location": "/BuildingExtensions/CustomConnectionTypes/", 
            "text": "Custom ConnectionTypes\n\n\nImplementing custom ConnectionTypes is similar to Node implementation, as it uses the same fetching system: \nDeclare a class inheriting from the \nIConnectionTypeDeclaration\n interface and specify it's properties.\n\n\n\n    \n\n    \n\n    ConnectionTypes.cs: Top: IConnectionTypeDeclaration; Bottom: Built-in Float type\n\n\n\n\n\nThe \nstring Identifier\n is used to address the type\n\n\nThe \nType Type\n is the type this declaration representates and which is used to check for connection compability\n\n\nThe \nColor Color\n is the color associated with the type, in which the knob textures as well as the connections are tinted with\n\n\nThe strings \nInKnobTex\n and \nOutKnobTex\n are the paths to the knob textures relative to '\nNode_Editor/Resources\n'. Defaults are '\nTextures/In_Knob.png\n' and '\nTextures/Out_Knob.png\n'\n\n\n\n\nDo not that the names may differ in previous versions!", 
            "title": "Custom ConnectionTypes"
        }, 
        {
            "location": "/BuildingExtensions/CustomConnectionTypes/#custom-connectiontypes", 
            "text": "Implementing custom ConnectionTypes is similar to Node implementation, as it uses the same fetching system: \nDeclare a class inheriting from the  IConnectionTypeDeclaration  interface and specify it's properties.  \n     \n     \n    ConnectionTypes.cs: Top: IConnectionTypeDeclaration; Bottom: Built-in Float type   The  string Identifier  is used to address the type  The  Type Type  is the type this declaration representates and which is used to check for connection compability  The  Color Color  is the color associated with the type, in which the knob textures as well as the connections are tinted with  The strings  InKnobTex  and  OutKnobTex  are the paths to the knob textures relative to ' Node_Editor/Resources '. Defaults are ' Textures/In_Knob.png ' and ' Textures/Out_Knob.png '   Do not that the names may differ in previous versions!", 
            "title": "Custom ConnectionTypes"
        }, 
        {
            "location": "/BuildingExtensions/AddingNodeCanvasTypes/", 
            "text": "Custom NodeCanvas\n\n\nNOTE: This is experimental and has not reached it's final state yet, many more features to come! This sections is very WIP!\n \n\nIt is possible to create custom NodeCanvas types to limit specific nodes to. For example, you can create a Dialogue canvas type with own, specific properties and even own traversal routines.\nSimply extend the NodeCanvas class and change properties. An example can be found on the branch \nExamples/Dialogue System", 
            "title": "Adding NodeCanvas Types"
        }, 
        {
            "location": "/BuildingExtensions/AddingNodeCanvasTypes/#custom-nodecanvas", 
            "text": "NOTE: This is experimental and has not reached it's final state yet, many more features to come! This sections is very WIP!   \nIt is possible to create custom NodeCanvas types to limit specific nodes to. For example, you can create a Dialogue canvas type with own, specific properties and even own traversal routines.\nSimply extend the NodeCanvas class and change properties. An example can be found on the branch  Examples/Dialogue System", 
            "title": "Custom NodeCanvas"
        }, 
        {
            "location": "/BuildingExtensions/AddingInputControls/", 
            "text": "Custom Input Controls\n\n\nNOTE: In the latest development branch, the Input system has been completely revamped. The following is not valid for older versions!\n \n\nFor your Editor Extension you might want to add custom controls or functions to the context clicks of both the canvas and the editor.\nUsing the new dynamic Input system it is very easy to do just that using four provided attributes which can be stacked as you wish.\nBefore explaining these in detail, it might be worth checking the default controls out in \nNodeEditorInputControls\n!\n\n\n\nNodeEditorInputInfo\n\n\nThe primary information container, \nNodeEditorInputInfo\n, contains all informations about an event including the editorState, the mouse position or the invoking event.\nIt is used to provide all necessary information to the dynamic input handlers.\n\n\n\nEventHandler Attribute\n\n\nThe \nEventHandlerAttribute\n is used to handle arbitrary events for the Node Editor and is the most flexible attribute.\nSome default controls like Node dragging, panning, zooming and Node connecting could only be implemented using this attribute.\nTagging a static function with this attribute makes it get called when the specified 'EventType' occurs (or always when no event specified).\nThe optional variable \npriority\n, next to the constructor variations, primarily defines the order of execution, but also a way to execute the input after the GUI (priority \n= 100).\nThe method signature \nmust\n be as follows:[ Return: Void; Params: NodeEditorInputInfo ]\n\n\n\nHotkey Attribute\n\n\nThe \nHotkeyAttribute\n is used to provide a simple interface for hotkeys for the Node Editor.\nSome default controls like Navigating ('N') and Snapping ('Control') are implemented using this attribute\nIt allows you to specify a \nKeyCode\n / \nEventModifier\n combination with a limiting \nEventType\n to specify when the tagged static function gets called.\nAgain, the optional variable \npriority\n can be specified. Refer to the \nEventHandlerAttribute\n for it's effect.\nThe method signature \nmust\n be as follows:[ Return: Void; Params: NodeEditorInputInfo ]\n\n\n\nContextEntry Attribute\n\n\nThe \nContextAttribute\n is used to register context entries for the Node`Editor.\nThe tagged function is called when the context element at the specified path is selected.\nIn which context menu to add this element is specified by the type, like the node context click or the canvas context click.\nThe method signature \nmust\n be as follows:[ Return: Void; Params: NodeEditorInputInfo ]\n\n\n\nContextFiller Attribute\n\n\nThe \nContextFillerAttribute\n is used to register context entries in the Node Editor in a dynamic, conditional or procedural way.\nThis function will be called to fill the passed context \nGenericMenu\n in any way it likes to.\nAgain the type specifies the context menu to fill.\nThe method signature \nmust\n be as follows:[ Return: Void; Params: NodeEditorInputInfo, GenericMenu ]", 
            "title": "Adding Input Controls"
        }, 
        {
            "location": "/BuildingExtensions/AddingInputControls/#custom-input-controls", 
            "text": "NOTE: In the latest development branch, the Input system has been completely revamped. The following is not valid for older versions!   \nFor your Editor Extension you might want to add custom controls or functions to the context clicks of both the canvas and the editor.\nUsing the new dynamic Input system it is very easy to do just that using four provided attributes which can be stacked as you wish.\nBefore explaining these in detail, it might be worth checking the default controls out in  NodeEditorInputControls !", 
            "title": "Custom Input Controls"
        }, 
        {
            "location": "/BuildingExtensions/AddingInputControls/#nodeeditorinputinfo", 
            "text": "The primary information container,  NodeEditorInputInfo , contains all informations about an event including the editorState, the mouse position or the invoking event.\nIt is used to provide all necessary information to the dynamic input handlers.", 
            "title": "NodeEditorInputInfo"
        }, 
        {
            "location": "/BuildingExtensions/AddingInputControls/#eventhandler-attribute", 
            "text": "The  EventHandlerAttribute  is used to handle arbitrary events for the Node Editor and is the most flexible attribute.\nSome default controls like Node dragging, panning, zooming and Node connecting could only be implemented using this attribute.\nTagging a static function with this attribute makes it get called when the specified 'EventType' occurs (or always when no event specified).\nThe optional variable  priority , next to the constructor variations, primarily defines the order of execution, but also a way to execute the input after the GUI (priority  = 100).\nThe method signature  must  be as follows:[ Return: Void; Params: NodeEditorInputInfo ]", 
            "title": "EventHandler Attribute"
        }, 
        {
            "location": "/BuildingExtensions/AddingInputControls/#hotkey-attribute", 
            "text": "The  HotkeyAttribute  is used to provide a simple interface for hotkeys for the Node Editor.\nSome default controls like Navigating ('N') and Snapping ('Control') are implemented using this attribute\nIt allows you to specify a  KeyCode  /  EventModifier  combination with a limiting  EventType  to specify when the tagged static function gets called.\nAgain, the optional variable  priority  can be specified. Refer to the  EventHandlerAttribute  for it's effect.\nThe method signature  must  be as follows:[ Return: Void; Params: NodeEditorInputInfo ]", 
            "title": "Hotkey Attribute"
        }, 
        {
            "location": "/BuildingExtensions/AddingInputControls/#contextentry-attribute", 
            "text": "The  ContextAttribute  is used to register context entries for the Node`Editor.\nThe tagged function is called when the context element at the specified path is selected.\nIn which context menu to add this element is specified by the type, like the node context click or the canvas context click.\nThe method signature  must  be as follows:[ Return: Void; Params: NodeEditorInputInfo ]", 
            "title": "ContextEntry Attribute"
        }, 
        {
            "location": "/BuildingExtensions/AddingInputControls/#contextfiller-attribute", 
            "text": "The  ContextFillerAttribute  is used to register context entries in the Node Editor in a dynamic, conditional or procedural way.\nThis function will be called to fill the passed context  GenericMenu  in any way it likes to.\nAgain the type specifies the context menu to fill.\nThe method signature  must  be as follows:[ Return: Void; Params: NodeEditorInputInfo, GenericMenu ]", 
            "title": "ContextFiller Attribute"
        }, 
        {
            "location": "/BuildingExtensions/BuildingAnEditor/", 
            "text": "Building a custom Editor\n\n\nThe provided Editor Window serves as the default Node Canvas Explorer for all dependant extensions that gets the job done.\nBut in order to make extensions that are built on top of this Framework unique, you'll sooner or later need to built your own Editor Interface.\nThe following outlines the most important things to consider in order to build a basic Node Editor Interface in both Runtime and the Editor.\n\n\n\n\nThe Canvas and Editor States\n\n\nThe Editor obviously has to stores the currently opened NodeCanvas and it's NodeEditorState in the first place.\nFor a detailed explanation of these, please look up the \nFramework Overview\n. \n\n\nNodeEditorUserCache\n is a wrapper class to aid your extension managing the canvas and editor state. For the majority of cases, it is perfectly fine.\nThe easy API for saving/loading and even caching in the editor works both in the editor and at runtime.\n\n\n\n\nThe Canvas GUI\n\n\nFor the GUI to look the same in the whole window and to allow for custom popups in your GUI, you first need to call \nNodeEditorGUI.StartNodeGUI\n. At the end you need to call \nNodeEditorGUI.EndNodeGUI\n. \n\nBefore you can draw the canvas area, first make sure a canvas is loaded and assign the rect for the canvas area to your \nNodeEditorState.canvasRect\n property.\nAlso, not that modifying the \nGUI.matrix\n scale while when drawing the canvas area is not yet supported. \n\nIn order to best account for errors that may be thrown, the drawing function should be embedded in a try-catch block that unloads the canvas when an error was thrown.\nMake sure you only catch \nUnityExceptions\n though, because of a Unity bug all pickers like \nColorField\n, \nCurveField\n or \nObjectField\n will throw an error when inside a \nSystem.Exception\n try-catch-block. \n\nIn this try-catch-block you can safely call \nNodeEditor.DrawCanvas\n, passing both the \nNodeCanvas\n and the \nEditorState\n, in order to draw the canvas in the specified area.\nAll additional interface elements like toolbar, side panel, etc. are up to you to handle, and are easily filled using the API of the Framework.\n\n\n\n\nCustom GUI Skin\n\n\nThe GUISkin of the Node Editor can currently only be changed by modifying the \nNodeEditorGUI\n source file or by replacing the textures. \nFor the future a more extensive and separated control over the GUISkin is planned.", 
            "title": "Building an Editor"
        }, 
        {
            "location": "/BuildingExtensions/BuildingAnEditor/#building-a-custom-editor", 
            "text": "The provided Editor Window serves as the default Node Canvas Explorer for all dependant extensions that gets the job done.\nBut in order to make extensions that are built on top of this Framework unique, you'll sooner or later need to built your own Editor Interface.\nThe following outlines the most important things to consider in order to build a basic Node Editor Interface in both Runtime and the Editor.", 
            "title": "Building a custom Editor"
        }, 
        {
            "location": "/BuildingExtensions/BuildingAnEditor/#the-canvas-and-editor-states", 
            "text": "The Editor obviously has to stores the currently opened NodeCanvas and it's NodeEditorState in the first place.\nFor a detailed explanation of these, please look up the  Framework Overview .   NodeEditorUserCache  is a wrapper class to aid your extension managing the canvas and editor state. For the majority of cases, it is perfectly fine.\nThe easy API for saving/loading and even caching in the editor works both in the editor and at runtime.", 
            "title": "The Canvas and Editor States"
        }, 
        {
            "location": "/BuildingExtensions/BuildingAnEditor/#the-canvas-gui", 
            "text": "For the GUI to look the same in the whole window and to allow for custom popups in your GUI, you first need to call  NodeEditorGUI.StartNodeGUI . At the end you need to call  NodeEditorGUI.EndNodeGUI .  \nBefore you can draw the canvas area, first make sure a canvas is loaded and assign the rect for the canvas area to your  NodeEditorState.canvasRect  property.\nAlso, not that modifying the  GUI.matrix  scale while when drawing the canvas area is not yet supported.  \nIn order to best account for errors that may be thrown, the drawing function should be embedded in a try-catch block that unloads the canvas when an error was thrown.\nMake sure you only catch  UnityExceptions  though, because of a Unity bug all pickers like  ColorField ,  CurveField  or  ObjectField  will throw an error when inside a  System.Exception  try-catch-block.  \nIn this try-catch-block you can safely call  NodeEditor.DrawCanvas , passing both the  NodeCanvas  and the  EditorState , in order to draw the canvas in the specified area.\nAll additional interface elements like toolbar, side panel, etc. are up to you to handle, and are easily filled using the API of the Framework.", 
            "title": "The Canvas GUI"
        }, 
        {
            "location": "/BuildingExtensions/BuildingAnEditor/#custom-gui-skin", 
            "text": "The GUISkin of the Node Editor can currently only be changed by modifying the  NodeEditorGUI  source file or by replacing the textures. \nFor the future a more extensive and separated control over the GUISkin is planned.", 
            "title": "Custom GUI Skin"
        }, 
        {
            "location": "/BuildingExtensions/EventsCallbacks/", 
            "text": "Events\n\n\nThe Framework supports a collection of events which might be important during the editing process. \nThose Events can either be received by subscribing to the appropriate delegate in the NodeEditorCallbacks class \nor by extending from NodeEditorCallbackReceiver (which is a MonoBehaviour) and overriding the appropriate method. \nBoth classes can be found in \nNodeEditorCallbackReceiver\n \n\n\nCurrent Events\n\n\n\n\nOnEditorStartup\n : The Node Editor gets initiated (can also happen when switching scene or playmode)\n\n\nOnLoadCanvas\n (NodeCanvas): The passed canvas has been loaded as a copy\n\n\nOnLoadEditorState\n (NodeEditorState): The passed editorState has been loaded as a copy\n\n\nOnSaveCanvas\n (NodeCanvas): The passed canvas has been saved as a copy\n\n\nOnSaveEditorState\n (NodeEditorState): The passed editorState has been saved as a copy\n\n \n\n\nOnAddNode\n (Node): The passed node has been created or duplicated\n\n\nOnDeleteNode\n (Node): The passed node will get deleted\n\n\nOnMoveNode\n (Node): The passed node has been moved by the user\n\n \n\n\nOnAddConnection\n (NodeInput): A new connection has been added to the passed input. If it had a connection before, \nOnRemoveConnection\n has been called, too\n\n\nOnRemoveConnection\n (NodeInput): The connection will get removed from this input\n\n \n\n\n\n\nWIP Transitioning System:\n\n\n\n\nOnAddTransition\n (Transition): The passed transition has been created\n\n\nOnRemoveTransition\n (Transition): The passed transition will be removed\n\n\n\n\n\n\n-\n Some of the Node-specific callbacks can also be accessed from the Node directly by overriding the appropriate method.\n\n\n-\n You can always implement additional callbacks or request them to be implemented!", 
            "title": "Events&Callbacks"
        }, 
        {
            "location": "/BuildingExtensions/EventsCallbacks/#events", 
            "text": "The Framework supports a collection of events which might be important during the editing process. \nThose Events can either be received by subscribing to the appropriate delegate in the NodeEditorCallbacks class \nor by extending from NodeEditorCallbackReceiver (which is a MonoBehaviour) and overriding the appropriate method. \nBoth classes can be found in  NodeEditorCallbackReceiver", 
            "title": "Events"
        }, 
        {
            "location": "/BuildingExtensions/EventsCallbacks/#current-events", 
            "text": "OnEditorStartup  : The Node Editor gets initiated (can also happen when switching scene or playmode)  OnLoadCanvas  (NodeCanvas): The passed canvas has been loaded as a copy  OnLoadEditorState  (NodeEditorState): The passed editorState has been loaded as a copy  OnSaveCanvas  (NodeCanvas): The passed canvas has been saved as a copy  OnSaveEditorState  (NodeEditorState): The passed editorState has been saved as a copy    OnAddNode  (Node): The passed node has been created or duplicated  OnDeleteNode  (Node): The passed node will get deleted  OnMoveNode  (Node): The passed node has been moved by the user    OnAddConnection  (NodeInput): A new connection has been added to the passed input. If it had a connection before,  OnRemoveConnection  has been called, too  OnRemoveConnection  (NodeInput): The connection will get removed from this input", 
            "title": "Current Events"
        }, 
        {
            "location": "/BuildingExtensions/EventsCallbacks/#wip-transitioning-system", 
            "text": "OnAddTransition  (Transition): The passed transition has been created  OnRemoveTransition  (Transition): The passed transition will be removed    -  Some of the Node-specific callbacks can also be accessed from the Node directly by overriding the appropriate method. \n-  You can always implement additional callbacks or request them to be implemented!", 
            "title": "WIP Transitioning System:"
        }, 
        {
            "location": "/FrameworkOverview/", 
            "text": "Framework Overview\n\n\n(NOTE: This page is WIP)\n\n\nThis section aims to bring you a decent overview on how the framework is structured, so you can get to modify it quickly. \nThis does not necessarily include implementation details \u2013 code sections that need extra detailing are commented. \nAlso, this section is not only for those planning to get into the code, but for everyone to get an overview what he's working with:)\n\n\n\n\nNodeCanvas\n and \nNodeEditorState\n\n\nThose two components essentially make up the save file you can load up into the Editor. \nBasically, the canvas stores all the nodes and any additional information directly related to the Canvas.\nIn contrary, the \nEditorState\n holds all information on the state, or in other words, on how the Canvas is presented.\nThis includes zoom and pan values, selected Nodes, the canvasRect, etc. Not all of these values are actually saved with the asset, though. \nThat structure allows for multiple 'views' on the same Canvas and editing it simultaneously.\n\n\n\n\nThe \nDrawCanvas\n function\n\n\nThis function acts very similar to any other GUI control, with a few exceptions, and is responsible for drawing the Canvas. \nOn the first glance it's just a wrapper for \nDrawSubCanvas\n, with the exception that it holds the \nOverlayGUI\n and \nNodeGUISkin\n code. \n\nDrawSubCanvas\n is used in the future for Nested Canvases, as the name proposes.\n\n\nFirst of all, the background texture is splattered across the canvas area based on zoom and pan values.\nThen, the function \nNodeEditorInputSystem.HandleInputEvents\n invokes all dynamic input handlers of the input system to catch all kinds of Input  events.\n\n\nAfterwards the scale area gets initiated with a call to the custom solution \nGUIScaleUtility.BeginScale\n. \n\nAny GUI code afterwards is getting scaled appropriately.\nThat means that now all elements that need to be scaled are drawn, including connections, node transitions, connections, bodies and knobs. \n\nThereafter, the scale area gets closed again with another call to \nGUIScaleUtility.EndScale\n. \n\n\nThe \nNodeEditorInputSystem.HandleLateInputEvents\n function then invokes the dynamic input handlers similar to the version before,\nwith the exception that only those that have to be handled after GUI are invoked.\n\n\n\n\nFramework Part explanations planned\n\n\n\n\nDynamic Input System at \nNodeEditorInputSystem\n\n\nConnectionType and Node fetching at \nNodeTypes\n and \nConnectionTypes\n\n\nKnob Behaviour and Possibilities at \nNodeKnob\n\n\nEvent/Callback System at \nNodeEditorCallbackReceiver\n\n\nSave System at \nNodeEditorSaveManager\n\n\nVarious Utilities like \nGUIScaleUtility\n\n\nCalculation System at \nNodeEditor\n\n\nTransitioning System including UnityFunc if they are ready\n\n\nRuntime GUI and limitations at \nRTEditorGUI\n mostly\n\n\nExperimental/Conceptional custom NodeCanvases and traversal algorithms", 
            "title": "Framework Overview"
        }, 
        {
            "location": "/FrameworkOverview/#framework-overview", 
            "text": "(NOTE: This page is WIP)  This section aims to bring you a decent overview on how the framework is structured, so you can get to modify it quickly. \nThis does not necessarily include implementation details \u2013 code sections that need extra detailing are commented. \nAlso, this section is not only for those planning to get into the code, but for everyone to get an overview what he's working with:)", 
            "title": "Framework Overview"
        }, 
        {
            "location": "/FrameworkOverview/#nodecanvas-and-nodeeditorstate", 
            "text": "Those two components essentially make up the save file you can load up into the Editor. \nBasically, the canvas stores all the nodes and any additional information directly related to the Canvas.\nIn contrary, the  EditorState  holds all information on the state, or in other words, on how the Canvas is presented.\nThis includes zoom and pan values, selected Nodes, the canvasRect, etc. Not all of these values are actually saved with the asset, though. \nThat structure allows for multiple 'views' on the same Canvas and editing it simultaneously.", 
            "title": "NodeCanvas and NodeEditorState"
        }, 
        {
            "location": "/FrameworkOverview/#the-drawcanvas-function", 
            "text": "This function acts very similar to any other GUI control, with a few exceptions, and is responsible for drawing the Canvas. \nOn the first glance it's just a wrapper for  DrawSubCanvas , with the exception that it holds the  OverlayGUI  and  NodeGUISkin  code.  DrawSubCanvas  is used in the future for Nested Canvases, as the name proposes.  First of all, the background texture is splattered across the canvas area based on zoom and pan values.\nThen, the function  NodeEditorInputSystem.HandleInputEvents  invokes all dynamic input handlers of the input system to catch all kinds of Input  events.  Afterwards the scale area gets initiated with a call to the custom solution  GUIScaleUtility.BeginScale .  \nAny GUI code afterwards is getting scaled appropriately.\nThat means that now all elements that need to be scaled are drawn, including connections, node transitions, connections, bodies and knobs.  \nThereafter, the scale area gets closed again with another call to  GUIScaleUtility.EndScale .   The  NodeEditorInputSystem.HandleLateInputEvents  function then invokes the dynamic input handlers similar to the version before,\nwith the exception that only those that have to be handled after GUI are invoked.", 
            "title": "The DrawCanvas function"
        }, 
        {
            "location": "/FrameworkOverview/#framework-part-explanations-planned", 
            "text": "Dynamic Input System at  NodeEditorInputSystem  ConnectionType and Node fetching at  NodeTypes  and  ConnectionTypes  Knob Behaviour and Possibilities at  NodeKnob  Event/Callback System at  NodeEditorCallbackReceiver  Save System at  NodeEditorSaveManager  Various Utilities like  GUIScaleUtility  Calculation System at  NodeEditor  Transitioning System including UnityFunc if they are ready  Runtime GUI and limitations at  RTEditorGUI  mostly  Experimental/Conceptional custom NodeCanvases and traversal algorithms", 
            "title": "Framework Part explanations planned"
        }, 
        {
            "location": "/license/", 
            "text": "Software license\n\n\nThe MIT License (MIT)\n\n\nCopyright (c) 2015 Baste Nesse Buanes\n\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.", 
            "title": "License"
        }, 
        {
            "location": "/license/#software-license", 
            "text": "The MIT License (MIT)  Copyright (c) 2015 Baste Nesse Buanes  Permission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:  The above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.", 
            "title": "Software license"
        }
    ]
}